Dependências:


Padronização (boa pratica):
Camadas -> a camada serviço retorna pro controller, o DTO e não a entidade, por isso uma classe GameDTO contendo os mesmo atributos da entidade original Game
evitando representação cíclica de objetos 

Service -> todo método do service colocar anotação para que fique transacional, garante que a operação com o BD vai acontecer, obedecendo os principios das transações ACID

APRENDIZADO:
API rest
java, springboot
ORM, JPA
Camadas, DTO (Data transfer object)

Modelo de dominio
Consulta sql
Projetions
Embedded id

Relacionamento n-n
Classe de associação, embedded id (BelongingPK)
Consultas SQL no Spring Data JPA (SQL(nativeQuery e não JP/QL (JPA)))
Projections (pra questão de uso de NativeQuery)

ORM
mapeamento de objeto relacional

MODELO DE DOMINIO
belonging é a terceira tabela do relacionamento de muitos pra muitos entre game e gamelist
a chave primaria aqui nessa tabela belonging é integrada, uma outra classe (objeto)

belonginpk é pra referenciar os dois ids que precisam ter na tabela belonging
a anotação embeddable serve pra encapsular dois atributos em uma classe para formar a chaves primarias das classes principais, que sao as estrangeiras da tabela

OBSERVAÇÕES: 
ao invés de import.sql, estou usando nesse projeto flyway para aprimorar habilidades

quando se usa 'nativequery' no repository, ou seja, sql e não JP/QL (jpa), o resultado da consulta tem que ser uma interface, no spring se chama 'projection'

 